"""
Review codes module for ACE-Bench evaluation.

This module provides functionality to save the agent-generated code for review.
"""

import docker
import logging
import os
import re
import shutil
import tarfile
import tempfile
from pathlib import Path
from typing import Any

import pandas as pd

UTF8 = "utf-8"


def extract_changed_files_from_patch(patch_content: str) -> list[str]:
    """
    Extract list of changed files from a git patch.

    Args:
        patch_content: Git patch content

    Returns:
        List of file paths that were changed
    """
    changed_files = []
    lines = patch_content.split('\n')

    for line in lines:
        # Match lines like: diff --git a/path/to/file.py b/path/to/file.py
        if line.startswith('diff --git'):
            match = re.match(r'diff --git a/(.+?) b/(.+)', line)
            if match:
                # Use the 'b/' path (after change)
                file_path = match.group(2)
                changed_files.append('/testbed/' + file_path)

    return changed_files


def add_agent_comments_to_patch(patch_content: str) -> str:
    """
    Add agent-generated comments to lines starting with '+' in the patch.

    Args:
        patch_content: Original git patch content

    Returns:
        Modified patch content with agent comments added
    """
    lines = patch_content.split('\n')
    modified_lines = []

    in_diff_section = False

    for line in lines:
        # Check if we're in a diff section (after @@)
        if line.startswith('@@'):
            in_diff_section = True
            modified_lines.append(line)
            continue

        # Check if we've left the diff section
        if line.startswith('diff --git') or line.startswith('---') or line.startswith('+++'):
            in_diff_section = False
            modified_lines.append(line)
            continue

        # Add comment to lines starting with '+' (but not '+++')
        if in_diff_section and line.startswith('+') and not line.startswith('+++'):
            # Check if line already ends with comment or is just '+'
            if line.strip() == '+':
                modified_lines.append(line)
            else:
                # Add comment at the end of the line
                modified_lines.append(line + '    #>>> This line was generated by agent. <<<')
        else:
            modified_lines.append(line)

    return '\n'.join(modified_lines)


def copy_from_container(container: docker.models.containers.Container, src_path: str, dst_path: Path) -> None:
    """
    Copy directory from container to host.

    Args:
        container: Docker container
        src_path: Source path in container
        dst_path: Destination path on host
    """
    # Get tar archive from container
    bits, stat = container.get_archive(src_path)

    # Create temporary file to save tar
    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
        for chunk in bits:
            tmp_file.write(chunk)
        tmp_path = tmp_file.name

    try:
        # Extract tar to destination
        with tarfile.open(tmp_path, 'r') as tar:
            tar.extractall(dst_path.parent)
    finally:
        os.unlink(tmp_path)


def exec_run_simple(container: docker.models.containers.Container, cmd: str, timeout: int = 300) -> tuple[int, str]:
    """
    Execute command in container and return exit code and output.

    Args:
        container: Docker container
        cmd: Command to execute
        timeout: Timeout in seconds

    Returns:
        Tuple of (exit_code, output_str)
    """
    result = container.exec_run(cmd, demux=False)
    output = result.output.decode(UTF8, errors='replace') if isinstance(result.output, bytes) else result.output
    return result.exit_code, output


def save_review_codes_level1(
    instance: pd.Series,
    patch_content: str,
    log_dir: Path,
    docker_image: str,
    logger: logging.Logger,
) -> None:
    """
    Save review codes for Level 1 instance.

    Level 1 workflow:
    1. Create container and restore project
    2. Apply instance patch (for masking)
    3. Add agent comments to agent patch
    4. Apply modified agent patch
    5. Copy /testbed/ (without .git) to review directory
    6. Save changed_files.txt

    Args:
        instance: Instance data
        patch_content: Agent-generated patch
        log_dir: Log directory for this instance
        docker_image: Docker image name
        logger: Logger instance
    """
    logger.info("=" * 60)
    logger.info("Saving review codes for Level 1")
    logger.info("=" * 60)

    # Create review directory
    review_dir = log_dir / "review"
    review_dir.mkdir(parents=True, exist_ok=True)

    client = docker.from_env()
    container = None

    try:
        # Create container
        container_name = f"ace_review_{instance['instance_id']}_{os.getpid()}".replace("/", "_").replace("__", "_")
        logger.info(f"Creating review container: {container_name}")

        container = client.containers.run(
            docker_image,
            command="/bin/bash -c 'sleep infinity'",
            name=container_name,
            detach=True,
            remove=False,
        )

        # Step 1: Restore project
        logger.info("Step 1: Restoring project")
        cmd = (
            "source /opt/miniconda3/etc/profile.d/conda.sh && "
            "conda activate testbed && "
            "rm -rf /testbed/* && "
            "cp -r /root/my_repo/* /testbed/"
        )
        exit_code, output = exec_run_simple(container, f"/bin/bash -c '{cmd}'")
        if exit_code != 0:
            logger.warning(f"Failed to restore project: {output}")

        # Step 2: Apply instance patch (masking)
        logger.info("Step 2: Applying instance patch for masking")
        instance_patch = instance.get('patch', '')
        if instance_patch and instance_patch.strip():
            # Write patch to temporary file
            with tempfile.NamedTemporaryFile(mode='w', suffix='.patch', delete=False, encoding=UTF8) as f:
                f.write(instance_patch)
                temp_patch_path = f.name

            try:
                # Copy patch to container
                bits = open(temp_patch_path, 'rb').read()
                container.put_archive('/tmp/', tarfile.open(fileobj=tempfile.NamedTemporaryFile(delete=False), mode='w'))

                # Simpler approach: use exec to write file
                patch_base64 = __import__('base64').b64encode(bits).decode('ascii')
                cmd = f"echo '{patch_base64}' | base64 -d > /tmp/mask_patch.diff"
                exec_run_simple(container, f"/bin/bash -c \"{cmd}\"")

                # Apply patch
                cmd = "cd /testbed && git apply --whitespace=fix /tmp/mask_patch.diff"
                exit_code, output = exec_run_simple(container, f"/bin/bash -c '{cmd}'")
                if exit_code != 0:
                    logger.warning(f"Failed to apply mask patch: {output}")
            finally:
                os.unlink(temp_patch_path)

        # Step 3: Add agent comments to patch
        logger.info("Step 3: Adding agent comments to patch")
        modified_patch = add_agent_comments_to_patch(patch_content)

        # Step 4: Apply modified agent patch
        logger.info("Step 4: Applying modified agent patch")
        if modified_patch and modified_patch.strip():
            # Initialize git
            git_init_cmds = [
                "cd /testbed && rm -rf .git",
                "cd /testbed && git init",
                'cd /testbed && git config user.email "ace@bench.com"',
                'cd /testbed && git config user.name "ACE Bench"',
                'cd /testbed && git add -A',
                'cd /testbed && git commit -m "Initial" --allow-empty',
            ]
            for cmd in git_init_cmds:
                exec_run_simple(container, f"/bin/bash -c '{cmd}'")

            # Write modified patch to container
            patch_base64 = __import__('base64').b64encode(modified_patch.encode(UTF8)).decode('ascii')
            cmd = f"echo '{patch_base64}' | base64 -d > /tmp/agent_patch.diff"
            exec_run_simple(container, f"/bin/bash -c \"{cmd}\"")

            # Apply patch
            cmd = "cd /testbed && git apply --whitespace=fix /tmp/agent_patch.diff"
            exit_code, output = exec_run_simple(container, f"/bin/bash -c '{cmd}'")
            if exit_code != 0:
                logger.warning(f"Failed to apply agent patch: {output}")

        # Step 5: Delete .git
        logger.info("Step 5: Deleting .git directory")
        exec_run_simple(container, "/bin/bash -c 'cd /testbed && rm -rf .git'")

        # Step 6: Copy /testbed/ to review directory
        logger.info("Step 6: Copying /testbed/ to review directory")
        testbed_dst = review_dir / "testbed"
        try:
            copy_from_container(container, '/testbed', testbed_dst)
            logger.info(f"Saved testbed to {testbed_dst}")
        except Exception as e:
            logger.error(f"Failed to copy testbed: {e}")

        # Step 7: Save changed_files.txt
        logger.info("Step 7: Saving changed_files.txt")
        changed_files = extract_changed_files_from_patch(patch_content)
        changed_files_path = review_dir / "changed_files.txt"
        with open(changed_files_path, 'w', encoding=UTF8) as f:
            for file_path in changed_files:
                f.write(f"{file_path}\n")
        logger.info(f"Saved changed files list to {changed_files_path}")

        logger.info("Review codes saved successfully for Level 1")

    except Exception as e:
        logger.error(f"Error saving review codes: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        if container is not None:
            try:
                container.stop(timeout=10)
                container.remove()
            except Exception as e:
                logger.warning(f"Failed to cleanup review container: {e}")


def save_review_codes_level2(
    instance: pd.Series,
    patch_content: str,
    log_dir: Path,
    docker_image: str,
    logger: logging.Logger,
) -> None:
    """
    Save review codes for Level 2 instance.

    Level 2 workflow:
    1. Create container and clean /testbed/
    2. Create README.md
    3. Initialize git
    4. Apply agent patch
    5. Delete .git
    6. Copy /testbed/ to review directory
    7. Save changed_files.txt with message

    Args:
        instance: Instance data
        patch_content: Agent-generated patch
        log_dir: Log directory for this instance
        docker_image: Docker image name
        logger: Logger instance
    """
    logger.info("=" * 60)
    logger.info("Saving review codes for Level 2")
    logger.info("=" * 60)

    # Create review directory
    review_dir = log_dir / "review"
    review_dir.mkdir(parents=True, exist_ok=True)

    client = docker.from_env()
    container = None

    try:
        # Create container
        container_name = f"ace_review_{instance['instance_id']}_{os.getpid()}".replace("/", "_").replace("__", "_")
        logger.info(f"Creating review container: {container_name}")

        container = client.containers.run(
            docker_image,
            command="/bin/bash -c 'sleep infinity'",
            name=container_name,
            detach=True,
            remove=False,
        )

        # Step 1: Clean /testbed/ and create README.md
        logger.info("Step 1: Cleaning /testbed/ and creating README.md")
        init_cmds = [
            "rm -rf /testbed/* /testbed/.*  2>/dev/null || true",
            "mkdir -p /testbed",
            'cd /testbed && echo "put all codes in this folder" > README.md',
        ]
        for cmd in init_cmds:
            exec_run_simple(container, f"/bin/bash -c '{cmd}'")

        # Step 2: Initialize git
        logger.info("Step 2: Initializing git")
        git_init_cmds = [
            "cd /testbed && git init",
            'cd /testbed && git config user.email "ace@bench.com"',
            'cd /testbed && git config user.name "ACE Bench"',
            'cd /testbed && git add -A',
            'cd /testbed && git commit -m "Initial" --allow-empty',
        ]
        for cmd in git_init_cmds:
            exec_run_simple(container, f"/bin/bash -c '{cmd}'")

        # Step 3: Apply agent patch
        logger.info("Step 3: Applying agent patch")
        if patch_content and patch_content.strip():
            # Write patch to container
            patch_base64 = __import__('base64').b64encode(patch_content.encode(UTF8)).decode('ascii')
            cmd = f"echo '{patch_base64}' | base64 -d > /tmp/agent_patch.diff"
            exec_run_simple(container, f"/bin/bash -c \"{cmd}\"")

            # Apply patch
            cmd = "cd /testbed && git apply --whitespace=fix /tmp/agent_patch.diff"
            exit_code, output = exec_run_simple(container, f"/bin/bash -c '{cmd}'")
            if exit_code != 0:
                logger.warning(f"Failed to apply agent patch: {output}")

        # Step 4: Delete .git
        logger.info("Step 4: Deleting .git directory")
        exec_run_simple(container, "/bin/bash -c 'cd /testbed && rm -rf .git'")

        # Step 5: Copy /testbed/ to review directory
        logger.info("Step 5: Copying /testbed/ to review directory")
        testbed_dst = review_dir / "testbed"
        try:
            copy_from_container(container, '/testbed', testbed_dst)
            logger.info(f"Saved testbed to {testbed_dst}")
        except Exception as e:
            logger.error(f"Failed to copy testbed: {e}")

        # Step 6: Save changed_files.txt
        logger.info("Step 6: Saving changed_files.txt")
        changed_files_path = review_dir / "changed_files.txt"
        with open(changed_files_path, 'w', encoding=UTF8) as f:
            f.write("all files under /testbed/ was generated by agent\n")
        logger.info(f"Saved changed files message to {changed_files_path}")

        logger.info("Review codes saved successfully for Level 2")

    except Exception as e:
        logger.error(f"Error saving review codes: {e}")
        import traceback
        logger.error(traceback.format_exc())
    finally:
        if container is not None:
            try:
                container.stop(timeout=10)
                container.remove()
            except Exception as e:
                logger.warning(f"Failed to cleanup review container: {e}")

